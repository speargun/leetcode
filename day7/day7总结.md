# 454四数相加II
用Map即可实现，核心思想是将四数之和化为二数之和，否则4重遍历的时间损耗太恐怖。分辨二重遍历前两个和后两个数组之和，先将前两个数组和的可能性都装入Map，再与后两个数组和做对比，即可得到答案。

# 383赎金信
非常简单的一题，就是要注意因为限制了可用的字符，所以可以用数组法节约时间。

# 15三数之和
本题最难度的点是答案中的三元组不能重复，因此去重的判断条件成了重中之重。不过在此之前，先讨论一下本题的实现方法。首先想到的自然是哈希法，然而哈希法的去重条件繁多，不如双指针法简约。

双指针法在本题的应用是这样的：首先将数组排序，令第一个数nums[i]遍历数组。每遍历一个数，就对剩余的数组[left=i+1,right=nums.length-1]进行检索，判断是否有成立的值。nums[left]和nums[right]分别指代第二个和第三个数。对于第一个数而言，每次都要等right<=left后才能开始遍历下一个数，且如果i>0时第一个数与上一次遍历时相同，则可以直接跳过到下一个数。当三数之和大于0时，收缩right，小于0时，收缩left，等于0时，则一直收缩right和left直到不与其对应的上一个数相同。这样，去重就完成了。

时间复杂度 O(n^2)
空间复杂度 O(1)

# 18四数之和
思路和上题相同，都是利用双指针的方式将时间复杂度降一个等级。不同的是，需要在外层再套一个循环，因此剪枝和去重操作有细微差别。而且，本题要求的是等于target而非等于0，因此剪枝时只用nums[a]>target是不够的，因为target有可能小于0，b,c,d也都可能小于0，这样即使第一个数比target大，依然可能有符合条件的答案。因此，要额外判断nums[a]>=0才能完成正确的剪枝。对于第二层循环的剪枝和去重来说，就是加上了第一层的条件而已。2层的剪枝需要判断1,2层相加是否大于target并且大于等于0，去重需要从b>a+1开始判断。

对于n数之和问题，不过是在此题基础上再嵌套额外的循环而已，思路都是一样的。

时间复杂度 O(n^3)
空间复杂度 O(1)