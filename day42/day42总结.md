# 背包问题基础
### 二维
dp[i][j]表示从下表为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。

确定递推公式：如果不放物品i，那么dp[i][j]=dp[i-1][j]。如果放物品i，那么dp[i-1][j-weight[i]]可以推导出dp[i][j]=dp[i-1][j-weight[i]]+value[i]。因此，有这两种情况可以得出dp[i][j]=max(dp[i-1][j],dp[i-1][j-weight[i]]+value[i])。
初始化的时候，如果背包容量为0，那么价值总和是0。因此dp[i][0]=0。而dp[0][j]则是i为0时个用量背包所能存放的最大价值。当j小于weight[0]时，dp[0][j]是0，而当j>=weight[0]时，dp[0][j]就是value[0]。其他位置统一写就行，在推导的时候都会被覆盖，可以填0。

推导顺序的话，都是从左上角向右下角推导。
### 一维
用一维数组表示时，dp[j]表示容量为j的背包其中物品价值最大为dp[j]。
dp[j]由dp[j-weight[i]]推导得出，dp[j]=dp[j-weight[i]]+value[i]。同时，因为要和其他物品比，因此要max(dp[j],dp[j-weight[i]]+value[i])。

初始化的时候，全部初始化为0即可。

遍历顺序：外层遍历物品，内层遍历背包容量。内层使用倒序，为了让物品不被重复计算。

# 416分割等和子集
背包最大容量j，最多能放dp[j]重量的物品。

当dp[target] = target时，包就装满了。

递推公式dp[j] = max(dp[j],dp[j-nums[i]]+nums[i]);

如果价值没有负数那么初始化0就行；有就初始化-Infinity。

外正内倒