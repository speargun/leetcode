# 二叉树基础
二叉树有很多有用且有趣的性质。满二叉树是除了最后一层，所有节点都有两个子节点，即只有度为0和度为2的节点，并且度为0的节点在同一层的二叉树。深度为K的二叉树有2^(k-1)个节点。完全二叉树则是除了最底层节点可能不满外，其余每层节点数都达到最大值，并且最底层的节点都集中在最左边的二叉树。最底层h包含1至2^(h-1)个节点。

二叉搜索树则是有序的树，是带数值排序的。若它的左子树不空，则左子树上所有节点的值都小于其父节点，右子树的值都大于其父节点。这样，二叉搜索树的子树也都是二叉搜索树。平衡二叉搜索树则是左右两个子树高度差绝对值不超过1的二叉搜索树，且其左右子树都是平衡二叉搜索树。

二叉树既可以链式存储，也可以顺序存储，其根本原理都是用数学方法排序后存放在线性表中。

二叉树的遍历方式主要有两种：深度优先遍历和广度优先遍历。深度优先遍历是先往深走，遇到叶子结点再往回走；广度优先遍历则是一层一层的遍历。深度优先遍历有三种实现方式：前序遍历，中序遍历和后序遍历，而广度优先遍历只有层序遍历一种。深度优先遍历既可以使用递归法实现，也可以使用迭代法实现，而广度优先遍历只能用迭代法。

# 二叉树的三种递归遍历
递归实现起来很简单，只需要按照遍历顺序要求调整递归的顺序即可。

## 144二叉树的前序遍历
前序遍历是先记录根节点，再左子节点，再右子节点，因此先将根节点放入数组，再依次递归左右子节点。

## 145二叉树的后序遍历
后序是先递归左右子节点再记录根节点。

## 94二叉树的中序遍历
中序是先递归左子节点再记录根节点再递归右子节点。

# 二叉树的迭代遍历
迭代法其实就是手动实现递归中系统自动管理的栈，然后再按照顺序处理栈中的数据放入result中。对于前序遍历来说，处理的和访问到的节点顺序是一致的，因此可以简洁地写出代码：先将根节点放入栈中，然后在循环中每次遍历时将栈头弹出放入结果中，再依次放入右节点和左节点。这样栈中先pop的就会是左节点。后序其实就是前序把左右的顺序换一下以后再对最后的结果reverse。中序稍微复杂一点，因为处理和访问到的节点顺序不一致，因此需要做判断。如果栈中无值，不一定要退出循环，要看是否cur，也即当前节点是否为空，如果也是空则代表全部遍历完毕。如果有当前值，则代表左子节点有值，需要先进栈，再让cur指向左子节点；如果没有cur，则开始往回找，将当前节点放入result并寻找右子节点。

# 二叉树的统一迭代法
虽然能实现二叉树的迭代遍历，但因为处理节点和访问节点的不同，导致写法并不统一。因此，可以将访问和要处理的节点都放入栈中，然后对要处理的节点做特殊标记，以实现统一的处理思路。做法是在要处理的节点放入栈后，将一个空指针放入作为标记。注意进栈顺序应是反序。