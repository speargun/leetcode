# 数组基础知识：数组是线性表的顺序存储方式，因而其内部的元素不会被删除，只会被覆盖，除非释放整个数组的内存空间。我对于线性表的了解还是全的，唯独不知道线性表的顺序存储方式有个名字，而且它就叫数组/流汗黄豆。

# 一。 704二分查找
题目链接：https://leetcode.cn/problems/binary-search/
文章讲解：https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html
视频讲解：https://www.bilibili.com/video/BV1fA4y1o715

闲话：二分法作为最简单易懂的算法之一，即使是常年不关心算法的我也对其有印象。然而就像Carl说的，道理都懂，写起来错误是各种各样，面试官总不会给我半小时debug吧/流汗黄豆。如果没瞟了一眼书上关于二分法实现的代码的话，我想仅凭我薄弱的大脑很难正确实现它（一开始我自己写的时候纠结了好久left和right到底应该是数字还是数组）。在初步实现了算法后，我提交到leetcode上的代码运行结果是超时。对此十分疑惑的我查看了标准解法，却并没有理解为什么会超时。于是，下一步就是看看系统性的讲解了。

对于任何区间来说，最重要的都是其边界的定义。边界的定义影响着每一次while循环中的处理，如果不能形成逻辑上的对应关系，则非常容易出现错误，导致最终答案的错误甚至死循环等严重bug。

常用的区间有两种：左闭右闭和左闭右开。对于二分法算法而言，这两种区间带来的区别体现在区间左边界和右边界是否应该相等，和左右边界移动的位置上：

左闭右闭：“区间的定义这就决定了二分法的代码应该如何写，因为定义target在[left, right]区间，所以有如下两点：
while (left <= right) 要使用 <= ，因为left == right是有意义的，所以使用 <=
if (nums[middle] > target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1”

左闭右开：“如果说定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。有如下两点：
while (left < right)，这里使用 < ,因为left == right在区间[left, right)是没有意义的
if (nums[middle] > target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]”

掌握了边界的定义，二分法的实现便轻而易举。

时间复杂度：O(log n)
空间复杂度：O(1)

ps.位运算的应用
位运算：从现代计算机中所有的数据二进制的形式存储在设备中。即 0、1 两种状态，计算机对二进制数据进行的运算(+、-、*、/)都是叫位运算，即将符号位共同参与运算的运算。
在JS中，位运算需要先将小数化为整数并转换为32位二进制整数格式。因此，运用位运算可以舍去结果中的小数。

# 二。27移除元素
题目链接：https://leetcode.cn/problems/remove-element/ 
文章讲解：https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html
视频讲解：https://www.bilibili.com/video/BV12A4y1Z7LP 

JS中，数组有自带方法splice()能够实现不占用额外空间删除元素（同时也能添加元素，参考https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.splice）。其实现原理就是基于数组的增删原理，根据元素的变化进行移位操作。但splice()的强大功能对于本题属于杀鸡用牛刀。

本题只需自行实现数组的删除原理即可。对于暴力解法而言，在双循环中遍历数组即可。外层循环负责检索与target相等的元素，而内层循环负责数组元素移位。

时间复杂度：O(n^2)
空间复杂度：O(1)

解法优化：双指针法的操作属实精妙。核心思想就是利用快慢指针将双循环压缩至单循环。因此，必须知道快慢指针各自的定义。

快指针：寻找新数组的元素。（新数组即无target的数组）
慢指针：指向需要更新元素的位置。

时间复杂度：O(n)
空间复杂度：O(1)

总结：要熟练双指针法的思想和实现，这是非常通用的一种优化方法。在看过Carl对代码的优化后，我认识到了资深程序员和小白之间巨大的差距，但同时也意识到了这种差距可以通过有效的学习积攒经验去弥补甚至超越（，总之慢慢培养这种意识吧。

# 三。35搜索插入位置
704的延伸，只需在return时判断一下大小返回不同位置即可。

时间复杂度：O(log(n))
空间复杂度：O(1)

# 四。34在排序数组中查找元素的第一个和最后一个位置
非递减顺序即非严格递增顺序；同理，非递增顺序即非严格递减顺序。

最开始没有想到用两个二分法，然后就因为一次二分法中同时判断左右区间混乱的逻辑白给了。

方法1：其实逻辑最简单，最贴近704的方法是先用一遍二分法查找，再根据查找结果做判断：如果查到了值，则向左右继续查找相同的值；如果没查到，那么返回[-1,-1]。

方法2：其次就是用两个二分法分别查找左右区间，再结合起来判断。如果有任一区间值为-2，即代表target比最小值还小或比最大值还大。如果左右区间差值大于1，则代表至少有一个合格的值，返回[left+1,right-1]即可。如果以上条件都不满足，则说明target在区间中且没有符合的值。

方法3：将两个二分法合并并非简单的叠加，因为区间大小可能不同，循环次数也可能不等。因此，需要额外加入flag值，对左右区间做不同判断才行。力扣官方答案的方法一中写到：“二分查找中，寻找leftIdx即为在数组中寻找第一个大于等于target的下标，寻找rightIdx即为在数组中寻找第一个大于target的下标，然后将下标减一。两者的判断条件不同，为了代码的复用，我们定义binarySearch(nums, target, lower)表示在nums数组中二分查找target的位置，如果lower为true，则查找第一个大于等于 target的下标，否则查找第一个大于target的下标。”这段文字中，lower即为判断的flag。这段文字清晰地描述了合并以后的判断逻辑。

在完成了二分函数后，需要对target的合法性进行判断。除了需要验证左区间小于等于右区间，左右区间的值都等于target以外，还需验证一项内容。力扣官方是用大于target进行的判断，因此需要验证右区间的合法性；我自己写的时候用的是小于target判断，因此在逻辑上需要反向操作，验证左区间的合法性。

时间复杂度：O(log(n))
空间复杂度：O(1)