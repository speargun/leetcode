博客内容：
今日学习的文章链接，或者视频链接
自己看到题目的第一想法
看完代码随想录之后的想法
自己实现过程中遇到哪些困难
今日收获，记录一下自己的学习时长

一。 704二分查找
题目链接：https://leetcode.cn/problems/binary-search/
文章讲解：https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html
视频讲解：https://www.bilibili.com/video/BV1fA4y1o715

闲话：二分法作为最简单易懂的算法之一，即使是常年不关心算法的我也对其有印象。然而就像Carl说的，道理都懂，写起来错误是各种各样，面试官总不会给我半小时debug吧/流汗黄豆。如果没瞟了一眼书上关于二分法实现的代码的话，我想仅凭我薄弱的大脑很难正确实现它（一开始我自己写的时候纠结了好久left和right到底应该是数字还是数组）。在初步实现了算法后，我提交到leetcode上的代码运行结果是超时。对此十分疑惑的我查看了标准解法，却并没有理解为什么会超时。于是，下一步就是看看系统性的讲解了。

对于任何区间来说，最重要的都是其边界的定义。边界的定义影响着每一次while循环中的处理，如果不能形成逻辑上的对应关系，则非常容易出现错误，导致最终答案的错误甚至死循环等严重bug。

常用的区间有两种：左闭右闭和左闭右开。对于二分法算法而言，这两种区间带来的区别体现在区间左边界和右边界是否应该相等，和左右边界移动的位置上：

左闭右闭：“区间的定义这就决定了二分法的代码应该如何写，因为定义target在[left, right]区间，所以有如下两点：
while (left <= right) 要使用 <= ，因为left == right是有意义的，所以使用 <=
if (nums[middle] > target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1”

左闭右开：“如果说定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。有如下两点：
while (left < right)，这里使用 < ,因为left == right在区间[left, right)是没有意义的
if (nums[middle] > target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]”

掌握了边界的定义，二分法的实现便轻而易举。

时间复杂度：O(log n)
空间复杂度：O(1)