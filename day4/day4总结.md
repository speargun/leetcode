闲话：调休了一下周六日

# 24两两交换链表中的节点
这道题是个模拟过程的题目，并不涉及什么算法，然而其代码细节很容易出错，进而造成程序的错误。本题同样有设立虚拟头结点和单独处理头结点两种写法。这里主要讨论虚拟头结点法。

在加入了虚拟头结点后，只要链表中存在两个及以上的节点（虚拟头结点排除在外），就要循环对两个节点进行交换操作。这里最容易出现的错误就是逻辑上的先后错误。首先，包括虚拟头结点在内，要先存储第二个和第四个节点（如果第四个节点为空则证明到了链表尾）。然后，先令第一个节点的next指向第三个节点，其含义为让上一个循环处理完毕的尾结点的next指向本次反转后的头结点。接着，让第三个节点指向第二个节点，即交换两节点位置。最后，让第二个节点指向第四个节点，从而让链表能够继续循环。

时间复杂度 O(n)
空间复杂度 O(1)

# 19删除链表的倒数第N个节点
依然是双指针思想。我最先想到的是先让fast指针遍历整个列表同时计数count，再让slow指针走count-n次，然而这并不是最优解。最优解是滑动窗口思想--最重要的是“滑动”，即窗口的两侧都在动。因此，先让fast指针走n个，再让fast和slow同时移动，这样在fast走到头时slow的位置就是要删除的位置了。注意，处理头结点是依然应用虚拟头结点思想。另外，在真正写代码时最好让slow停在要删除的上一个节点，方便修改next。

时间复杂度 O(n)
空间复杂度 O(1)

# 160链表相交
这道题就不用Carl的写法了，因为他的写法还要用循环测一遍两个链表的长度再利用一个循环求相交，实际的时间复杂度是O(m+n+Max(m,n))。更简洁的写法是利用两个指针先分别指向两个链表，当某一个指针到头时再指向另一个链表的头结点，然后继续循环直到找到相交节点。这种循环方式确保能退出的原因是，两个指针同时行动，并且行进的路程都是m+n，因此即使两链表不相交，两个指针也会在最后同时指向null。这种写法的实际时间复杂度是O(m+n)。要注意的是精简判断条件，并尽可能优化代码结构。

时间复杂度 O(m+n)
空间复杂度 O(1)

# 142环形链表II
对于这题来说，我能想到的极限就是空间复杂度为O(n)的方法。先新建一个指针指向头结点。每当该指针前进一步，则再新建一个指针指向头结点，并且每次也前进一步，直到第一个指针与某个指针相遇，或第一个指针指向null。这样一来，通过判断是第几个指针与第一个指针相遇就可以判断环的大小。

空间复杂度为O(1)的方法则更巧妙。新建两个指针指向头结点。fast指针每动两次，slow指针动一次。这样，这两个指针如果fast指向null，则无环；如果相遇，则一定是在环内相遇。我也想到了这种方式，但我没有想到该如何计算环的大小，于是就放弃了这个思路。我没有想到的是，slow与fast相遇时，slow一定没有走完第一圈环。于是，slow走过的节点数就为x+y，其中x是进入环之前的长度，y是slow在环内走过的距离。此时，fast走过的节点数是x+y+n(y+z)，其中n是fast已经走过的圈数，z是环的长度减去y。同时已知的是，fast的速度是slow的两倍，因此可以列式得2(x+y) = x+y+n(y+z)。
环的入口位置x=n(y+z)-y。再整理一下后，x=(n-1)(y+z)+z。可以的得知的是，n≥1，因为fast至少要多走一圈才能遇到y。

当n=1时可以得到x=z，也就意味着当一个指针从头结点出发，另一个指针从slow和fast相遇的节点出发时，他们相遇的地方就是环的入口节点。当n大于1时，意味着要多转几圈，但最终相遇位置还是环的入口节点。这样一来，找到环入口节点的思路就完成了。

