# 一。977有序数组的平方
### 暴力解法
这道题的暴力解法十分简单，直接用两个循环搞定即可。第一个循环求平方，第二个循环用排序方法（这里不深究用什么排序方法，因为还没有学到）。ES没有规定具体sort()函数的实现方法，如果为快排则时间复杂度为O(nlog(n))。在此我使用了最低效的排序方法，遍历排序法，时间复杂度为O(n^2)。

### 双指针法
双指针法则使得时间复杂度大大降低。虽然乘方以后数组的排序会乱，但乘方前的数组排序还是有规律的。因此，可以得知越靠近数组中间的值乘方后越小，因此只需分别用两个指针比较数组首尾的值大小再依次放入新数组中即可。注意每次比较完要将放入数组中那边的指针前进/后退一位。

循环的条件不止一种。既可以用left<=right做判断条件，也可以用新数组下标>=0做判断条件，从数学角度来说是等价的，因为每次不是left加就是right减，最后循环次数刚好等于填满新数组的循环次数。

时间复杂度：O(n)
空间复杂度：O(n)

# 二。209长度最小的子数组
### 暴力解法
本题的暴力解法依然是循环嵌套。设子序列起点为i，终点为j，通过双重循环比较result与subLength=j-i+1的大小即可记录符合条件的最小的子序列长度。最后返回结果时，若result依然是初始值（Infinity）则返回0即可。

我对于循环条件的优化，变量的设置依然需要更精细的考量。在自己的初版中，我没有对循环的提前跳出做判断，因而白白浪费了许多时间。主要的原因在于对循环中变量的含义不明：我认为j是从第几个元素开始加和，而实际上更好的理解是子序列终点，这样子序列长度就不用count++计算，而是可以用j-i+1表示。这种理解方式也更便于想到如何提前跳出循环。

### 滑动窗口思想
闲话：不得不感慨数学的作用以及有一张动图对于理解算法的帮助有多么大。

滑动窗口是在一个循环中动态的调整子序列起始位置和终止位置来得到最终结果的方法。基于我之前对滑动窗口的印象再结合昨天对于双指针的理解，我认为滑动窗口的起始和终止位置就相当于一快一慢两个指针。快的指针，即终止位置，应当是要遍历整个数组的，所以作为循环的条件再适合不过。每当加和超过target时，便可记录当前窗口大小并尝试将慢指针（即起始位置）右移，直到加和小于target时，再将终止位置右移。最后，每个元素都进出过窗口一次，所以时间复杂度是2n，记为O(n)。
Carl说：“不要以为for里放一个while就以为是O(n^2)啊， 主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被操作两次，所以时间复杂度是 2 × n 也就是O(n)。”

时间复杂度：O(n)
空间复杂度：O(1)

# 三。59螺旋矩阵II
闲话：果然找不好不变量没有好果子吃。就像见多识广的Carl预言的那样，我作为他口中的“部分学生”深陷错误的判断条件中不能自拔。

螺旋矩阵最关键的点就是找好区间。最开始我没有想好转向与边的关系就开始硬试条件，然而每次都是写了几个判断句就感觉得不到正确的结果而删掉重新思考。在看了一眼Carl的矩阵图后，我意识到了转向和边的关系：每次转向前画的边长总是实际看起来的边长-1。在明确了这条以后，我以每画一圈为大循环，每画一条边为小循环，成功的测试通过了n=2的矩阵。然而，此时的我还有两个问题没有考虑到：1.更大的矩阵带来的内圈边长缩短问题；2.n为奇数时最中间一格的填充问题。发现过程痛苦而又无聊，不再赘述。

1.对于更大的矩阵来说，只转一圈肯定是画不完整个矩阵的，因此需要一直循环着画直到填充完毕。然而，每一圈循环的边长都要缩减2，因此要设置一个单独的变量offset进行补偿。

2.n为奇数时，画到最中间一格时内层画边用的for循环会因为n-offset=0而不执行，因此外层的while循环也会因为count==n*n而不退出导致死循环，因此需要单独判断在n-offset<1时单独绘制最后一格。

之后我详细的看了Carl的实现。Carl是以每画一圈为循环并在循环内根据设定好的起始位置分别画四条边实现的矩阵。控制条件不同，但背后的核心算法没有区别，因此理解并记录在了js文件中，也不再多写了。

时间复杂度：O(n^2)
空间复杂度：O(1)

今日又是猪脑过载的一天，然而收获还是不小的。我对于双指针的用处有了更深的理解，并且螺旋矩阵也是强化了前一天对于区间边界的练习。