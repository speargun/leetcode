# 239滑动窗口最大值
JS的实现与C++有很大的不同，这也导致了有时候即使思路清晰，在实现时也会因为底层代码实现原理的不同带来很大的写法差异。本题的基本思路是利用单调递减队列。队列中存储的值应该是有可能被当作最大值的元素（这点有细节后面说）。如何定义有可能被当作最大值的元素呢？如果该元素的右侧有比自己大的值，那么随着窗口向右移动，它永远不可能是最大值，因此可以排除。而如果一个元素右侧的值比它小，那么随着窗口的移动，当该元素退出窗口时，它右侧的元素还有可能成为最大值。因此，应该保持一个单调递减的队列。当窗口右移时，如果新元素比它左边的元素大，那么就可以删除左边的元素直到遇到比自己大的元素或者左边已没有元素。同时，如果队首的元素是上一个窗口的值，那么还要将其删除。这样，就可以实现要求。

然而，有点细节需要注意。当给定的数组中包含大量相等元素时，这个函数的运行会变得及其漫长，因为对于每个窗口而言，都需要循环所有相同值和更小的值直到遇到更大的值。而因为数组中相同的值众多，单调递减队列无法将这些本应无效的值剔除，从而使得每次循环都要遍历K次队列，而当K超大时，这个时间损耗是极其恐怖的。那么为什么不判断相等呢？因为当队列中存储的是值而非下标时，队列与原数组无法形成可靠的一一对应关系，使得在数组极其乱序的情况下无法判断相等的值是否可以删除（也许可以判断，我暂时没有想到解决方案，但这同时也说明其判断条件的复杂性），因而只能祈祷数组中不要出现大量相等数组。

解决方法就是转而存储下标。在判断值大小时只需额外套一层`[]`即可，例如从`queue[queue.length-1]`变成`nums[queue[queue.length-1]]`。这样，就可以在push进队列的判断条件中加上等号了。当然，还需要注意队列pop方法的改变。原先的pop因为没有一一对应关系只能判断是否数值相等，而现在只用判断是否下标比窗口左侧小即可。这样，对于一个K=100000，数组中的值是500000个相等值的情况，运行速度从5.3秒加快到了0.019秒，因为旧方法每次循环中都要遍历一遍长度为100000的队列，而新方法每次循环只需要遍历长度为1的队列。

时间复杂度 O(n)
空间复杂度 O(k)

# 347前K个高频元素
本题核心思想是优先级队列。堆是完全二叉树，树中的每个节点值都不小于（或不大于）其子节点的值。如果都不小于，则是大顶堆，如果都不大于，则是小顶堆。而优先级队列则是使用队列进出规则的堆。因此，优先级队列中的push只能加到堆尾，pop只能推出根节点，即如果使用小顶堆，每次pop的就是出现次数最少的元素。本题中，先使用Map存放所有元素的出现频率，再用优先级队列对前K个元素排序。如果堆中元素数量不超过K个，则将Map元素放入堆；如果超过了，则pop一个元素（其中涉及重新排序，后面说）。这样，最后剩下三个就是出现次数最多的元素，而如果使用大顶堆，则每次pop的都会是出现频率最高的元素，没法保存。需要注意的是，因为使用的是小顶堆，所以顺序是反的，最后要倒序返回结果。

JS中并没有堆这一数据结构。那么要怎么实现堆呢？从定义入手。首先，因为堆其实是完全二叉树，所以其中要包含一个数组以及回调排序方法。数组就是完全二叉树的容器，其中的元素将以完全二叉树的几大数学规则巧妙地填入。回调排序方法就是决定这个堆是大顶堆还是小顶堆的方法。如果传入a-b，则是小顶堆，如果传入b-a，则是大顶堆。当然也可以反着实现，但通用的是这个顺序。堆中有四个方法，分别是push，pop，size和compare。size最简单，就是数组的长度。compare函数则是根据回调函数返回结果，并对传入的值无效做出了特殊处理。push和pop都会触发重排。重排的具体规则如下所述：

push：push的节点和父节点对比，如果父节点更大，则交换位置，并再次与新的父节点对比，直至满足条件。

pop：pop节点后，将堆尾的节点至于根节点，并与左右子节点中较大的节点对比，如果根节点比子节点大，则交换，并在此于心的子节点对比，直至满足条件。