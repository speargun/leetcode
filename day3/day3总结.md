# 链表理论基础
关于数据结构基础，要系统的学习才能更好的帮助理解算法，提供更好的思路。因此，系统的学习数据结构是必须的。

对于链表来说，与数组最大的不同就是存储结构的不同。数组是线性表中的顺序存储结构，它在内存中的存储空间是连续的，而链表则是离散地分布于内存中，只通过指针来储存下一个/上一个节点的地址来实现节点的互相连接。因为二者增删改查的时间复杂度不同，因此要熟练掌握它们的各种操作以便于在不同场合选择适合的数据结构。
# 203移除链表元素
移除链表元素是比较简单的，然而重要的还是理清操作的先后顺序，否则就会造成节点丢失，死循环等问题。看过leedcode提供的ListNode结构之后，我发现他们实现的链表没有伪头结点，即无法直接对头节点进行操作。因此，要首先在头结点前加上一个伪头结点指向真头结点，再创建指针遍历数组进行判断。另一种方法则是单独对头节点做出处理，循环检测头结点直到头结点不用被删除，再对链表中的其他节点做处理。

在判断节点时，也有两种判断方法。我采用的是判断当前节点并删除的方法。这种方法需要提前储存上一个节点，用来将上一个节点的next指向当前节点的next从而删除当前节点。另一种方法则是对当前节点的next节点做判断。这种方法无需储存上一个节点，但循环的跳出条件需要额外判断当前节点的next是否为null。

时间复杂度 O(n)
空间复杂度 O(1)

# 707设计链表
这道题就是根据链表数据结构的原理设计链表，考察的就是代码掌握程度。我最开始把链表当成了节点来写，结果错的一塌糊涂。其实，应该单独声明节点的数据结构，再用构造函数创建链表。本题我写的是双向链表，所以节点中包含val,next和prev。初始化链表时，表中包含两个额外的信息：虚拟头结点和表长。这样在后续写方法是能更轻松地做判断。

# 206反转链表
反转链表的逻辑就是用一个变量储存上一个节点并把next指向它。我最开始想到了用prev，但是没有想到用变量储存这个既简单又清晰地方式，反而去尝试给每个节点都添加一个prev属性。这既改变了数据结构，也显得十分繁琐。于是我放弃了这个思路，并转而用数组的push和pop实现了反转链表。然而，这种实现方式不仅时间复杂度是2n，空间复杂度也是达到了n。

用变量储存prev这个方式只需先让prev等于null来模仿尾结点的next值，然后在每次循环中用temp储存node原本的next再将node的next指向prev。

递归方法的思路和用prev进行循环是一样的，然而其控制条件更为抽象，更加难以理解其内涵。在循环法中，在开始循环前初始化的变量，既是递归法中每次递归传递的变量，而while的跳出条件，同时也就是递归结束的条件。每次递归中的内容，即是循环法的循环中剩余的部分。

时间复杂度 O(n)
空间复杂度 O(1)

ps.在做测试的时候一定要明确测试的函数会不会改变原本的值。如果不明确就有可能像我一样在测试的时候连着用两次反转函数然后不明白为什么链表顺序没变进而de了半小时bug。。。