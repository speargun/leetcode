# 回溯算法基础
回溯是一种算法，也叫作回溯搜索法，是一种搜索的方式。它是递归的副产物。回溯法究其本质爱是穷举，虽然为了提高效率可以加入一些剪枝的操作，但改变不了其穷举的本质。需要应用回溯算法的题，一般也没有更加高效的解决方式。

回溯法可以用来解决这几种问题：

1. 组合问题：n个数中按一定规律找出k个数的集合
2. 切割问题：一个字符串按一定规则有几种切割方式
3. 子集问题：一个N个数的集合中有多少符合条件的子集
4. 排列问题：N个数按一定规则全排列，有几种排列方式
5. 棋盘问题：N皇后，解数独等等

### 如何理解回溯法？
回溯法解决的问题都可以抽象为树形结构，因为回溯法解决的都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度以及树的深度。因为递归有终止条件，因此必然是一颗高度有限的N叉树。

### 回溯法模板
* 回溯法的模板返回值以及参数：函数返回值一般是空；参数一般是先写逻辑，按照逻辑的需求填参数。
* 回溯函数终止条件：一般到达叶子结点就会找到相关答案（不是通解）。总之，只要达到了终止条件，就存放结果并返回。
* 回溯搜索的遍历过程:

`for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
    处理节点;
    backtracking(路径，选择列表); // 递归
    回溯，撤销处理结果
}`

for循环就是横向遍历，递归就是纵向遍历。

回溯法模板：

`void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}`

# 77组合
该题就是回溯算法的典型应用。首先应该将问题转化为树的结构，方便进行思考。每一层，都是确定了一个数后，在剩余的数字中选择数字的过程。而在每一层中，for循环则是用来选择选择当前确定哪个数的过程。对于集合来说，遍历还是有优化空间的。如果for虚幻选择的起始位置之后的元素个数已经不足所需的元素个数k时，那么就没有必要继续本层的搜索了。